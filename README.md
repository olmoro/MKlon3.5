# <p align="center"> MKlon3.5
## <p align="center">Зарядное устройство на модулях ESP32DEVKITCV4, SAMD21 MINI и ILI9486 3.5".
### <p align="center">(реализация конечного автомата в проекте зарядного устройства)
## <p align="center">Проект Arduino.
#### <p align="right">2023.05.05

### MKlon3.5 - это вариант компоновки проекта MKlon2 с сохранением основных параметров, исключая разве что пользовательский интерфейс, реализованный на дисплее ILI9486 3.5 дюйма с сенсорной панелью. Реализована "этажерочная"  конструкция из трёх плат: дисплей и две платы размером 100х62 мм — плата управления и силовая плата. Используя преимущества четырехточечного подключения заряжаемой батареи применены силовые ноутбучные разъёмы. Как вариант прибор может быть дополнен выносным пультом управления, дублирующим управление семейством зарядных устройств (5-кнопочная клавиатура, карта памяти SD-фактора, 6 разъёмов безадресного подключения DS18B20, индикатор 128х128) - по беспроводной связи с базовым блоком. Предусмотрены также разъемы для подключения логического анализатора к выводам обоих модулей - ESP32 и SAMD21 и сигнальные светодиоды.

### Аппаратная часть проектировалась в среде Eagle v7.3.0, программная - в PlatformIO. 

<a name="menu"></a>
1. [Как это работает. Аппаратный аспект.](#hard)
- [Межпроцессорное соединение.](#cpu)
- [Межпроцессорный обмен.](#uart)
- [Измерители.](#measure)
- [Схема разряда.](#discharge)
- [Подключение заряжаемой батареи.](#akb)
- [Питание модулей.](#dc5v)
- [Силовой DC/DC преобразователь.](#power)
- [Подключение вентилятора.](#cooler)
- [Пульт-логгер.](#pult)
2. [Как это работает. Программный аспект](#soft)
- [Структура проекта](#main)
- [State.](#state)
- [Вычисление среднего](#sum)
3. [Технические характеристики](#specifications)
4. [FSM](#fsm)
5. [Первый проект](#first_project)
6. [Драйвер SAMD21](#driver)
- [Выбор аналоговых портов](#port)
- [Коэффициент пересчета в миллиамперы](#kma)
- [Коэффициент пересчета в милливольтры](#kmv)
- [Выбор таймера ШИМ](#timer2")
- [Выбор ПИД-регулятора](#fast_pid)
- [Подбор параметров](#par_pid)
7. [Документы](#docs)
- [Схема платы управления](#sch1)
- [Схема силовой платы](#sch2)
8. [Полезные ссылки](#useful_links)
9. [About Me](#about)

***
![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/MKlon3.5full.png)

## <p align="center"> Как это работает.<a name="hard"></a>
В зарядном устройстве пользовательский интерфейс реализован на модуле с ESP32 (ESP), а управление модулем силовой платы производится по последовательному каналу. На ESP обслуживается дисплей, RGB индикатор, зуммер, система контроля питания, система охлаждения, интерфейс драйвера силовой платы, USB, WiFi, BT. В памяти ESP хранятся заводские и пользовательские настройки. Оператору предоставляется возможность выбрать посредством меню требуемый режим работы, задать параметры и запустить. Настройки беспроводной сети позволяют в реальном времени на удаленном компьютере не только наблюдать в виде графиков процесс: напряжение, ток, баланс заряда/разряда, температуру, работу системы охлаждения, но и управлять им. Программное обеспечение ESP построено таким образом, что позволяет даже непрофессиональному программисту реализовать свой собственный алгоритм, воспользовавшись методикой из репозитория FSM.

Весь, или почти весь реалтайм реализован на отдельном модуле SAMD21 MINI (D21). Связь c ESP осуществляется по асинхронному каналу. Модуль D21 получает команду, по которой включаются соответствующие ресурсы: АЦП тока и напряжения, ШИМ-генератор, ЦАП управления разрядом, коммутатор выхода и др. Автоматически поддерживается устойчивость силового преобразователя при работе на малую нагрузку или на холостом ходе, отключение при перегрузках. Поддерживается режим быстрого разряда накопительных конденсаторов через нагрузку для разряда, минуя датчик тока, дабы не искажать подсчет ампер-часов. Когда возможно допускается регулировка параметров "на лету", иначе D21 переводит силовую часть в безопасный режим с выдачей сообщения управляющему контроллеру. D21 поддерживает управление зарядом и разрядом как командами, так и с помощью собственного ПИД-регулятора. Настройки коэффициентов для поддержания тока и напряжения могут быть разные. Выбор ПИД-регулирования имеет 4 режима: отключено, по току, по напряжению и с автовыбором по типу реализованного в TL494. Измерения напряжения на батарее производятся по четырехпроводной схеме в диапазоне от -2 до +18 вольт. Ток разряда измеряется на том же шунте, что и ток заряда от -10 до +10 ампер. Параметры фильтрации измерений задаются командами.

Питание прибора производится от внешнего AC/DC преобразователя (БП) на 18...19 вольт 6...9 ампер, что определяет выходные параметры зарядного устройства и делает само устройство с точки зрения электробезопасности более привлекательным.

В разделе "Как это работает" позиционные обозначения на рисунках могут отличаться от имеющихся в документации.

***
## <p align="center">1. Как это работает. Межпроцессорное соединение.<a name="cpu"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/interprocessor.png)

Здесь реализована как минимум одна хитрость: модуль SAMD21 MINI запитан от изолированного источника питания со смещением в "минус" примерно на 200 милливольт, необходимые для дифференциальных измерений напряжения и тока. При реализованной топологии печатной платы существенного влияния на обмен по асинхронному интерфейсу не обнаружено.

Однако есть и недостаток: при одновременном подключении к одному компьютеру обоих USB указанное смещение становится равным нулю. И в результате как напряжение, так и ток отрицательной полярности при любом их значении индицируются вблизи нуля. Всё бы ничего, но в режиме разряда PID-регулятор поддержания установленного тока просто "сходит с ума" - всё добавляет и добавляет, пока ток не "упрется" в максимум, определённый сопротивлением нагрузки.

Но до этого, думаю, дело не дойдёт - это ж надо быть каким крутым программистом, чтобы одновременно кодировать два разных проекта...

Активным в связке является ESP32, который генерирует запрос по асинхронному интерфейсу. Линия READY - резервная, При экспериментах служит для синхронизации логического анализатора.
[^](#menu)

***
## <p align="center"> Как это работает. Межпроцессорный обмен.<a name="uart"></a>

  Связь между управляющим и измерительным контроллерами в части физического интерфейса 
состоялась в пользу UART, аппаратная реализация которого намного проще, чем прожорливый 
и склонный к "неожиданностям" капризный I2C.

  На логическом уровне обмена данными существуют различные протоколы, но они обычно 
избыточны для реализации управления простыми микроконтроллерными устройствами, а потому 
применять такие протоколы не имеет смысла и выбор пал на протокол Wake, который был создан 
специально для реализации такой связи.

  Для надежного обнаружения начала пакета в потоке данных протокол Wake использует 
специальный зарезервированный символ, который в потоке данных встречаться не может. При 
необходимости передачи такого символа он заменяется последовательностью из двух символов 
(используется так называемый байт-стаффинг).

  Обмен идет посылками на скорости 230400 бод. Формат посылки (команды), как запроса, 
так и ответа выбран таким, чтобы укладываться в отведенные 500-600 микросекунд между 
регулярными циклами (1кГц) измерений тока и напряжения, включающих регулирование, 
обработку перегрузок и т.п. В пересчете на байты это не более 6-8 байт данных плюс 4 
служебных (стартовый, код команды, число байт и контрольная сумма пакета) и ещё должен 
быть запас на возможный байт-стаффинг. Данные передаются только как целочисленные и 
только один раз за 100 мс.

  Управляющий ESP32, если нет запроса на посылку целевой команды, отправляет запрос на 
получение данных от измерителя (2 байта напряжения и 2 байта тока) и 2 байта состояния 
SAMD21. Напряжение и ток в физических единицах - милливольтах и миллиамперах со знаком.
А два байта состояния дают исчерпывающие данные для управления процессом, учитывая то, 
что весь "реал-тайм" исполняется контроллером SAMD21 и не требует "мгновенного" 
вмешательства управляющего ESP32 в процесс целевой командой. В таком случае одно 
измерение из 100 заменяется предыдущим, что практически не заметно при визуализации как 
на дисплее, так и браузере.
[^](#menu)

***
## <p align="center"> Как это работает. Измерители.<a name="measure"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/ui_measure.png)

Измерение напряжения и тока производится по дифференциальной схеме. Микроконтроллер SAMD21 предоставляет такую возможность. Только следует учесть, что 12-разрядный АЦП становится фактически 11-разрядным плюс знаковый разряд. И рассчитывая параметры шунта и делителя напряжения следует оперировать половинным значением опорного напряжения. На входах установлены НЧ фильтры и диоды защиты. А чтобы при манипулировании с "крокодилами" вход измерителя напряжения не повисал неподключенным, одноимённые силовой и измерительный провод соединены резисторами (на рисунке не показаны).
[^](#menu)

***
## <p align="center"> Как это работает. Вычисление среднего.<a name="sum"></a>

Не вызывает никаких сомнений метод вычисления среднего за определенный интервал, когда сумму измерений делят на их число. Однако для получения следующего среднего придется всё повторить с начала, и на это потребуется время. Но есть метод, когда на следующем цикле измерения убирается (вычитается) самый ранний уровень и добавляется (прибавляется) новый, а затем вычисляется среднее. Всё бы хорошо, но чтобы сохранить все эти уровни может потребоваться немалый расход памяти. Есть метод, позволяющий устранить этот недостаток, заменив вычитаемый ранний уровень средним значением, и называется он скользящим средним. Наибольший выигрыш дает не произвольное число измерений, а кратное степеням двойки: 2, 4, 8, 16, тогда операцию деления можно заменить арифметическим сдвигом. Соответственно буфер (sum) для накопления должен иметь такое число разрядов, чтобы не возникало переполнения. Функция вычисления для 16-разрядного ADC может выглядеть так:
```c++
int16_t averageU(uint8_t k) 
{
  static int32_t sum = 0;  // объявили и инициализировали сумматор удвоенной, чем ADC разрядности 
  int16_t avrU = sum >> k;  // вычислили среднее за прошлый интервал (накопленное поделили на число измерений)
  sum += adcU - avrU;    // к сумматору добавили разность между новым измерением и средним
  return int16_t(sum >> k);  // вернули новое значение среднего
}
```
Внимание! Будьте внимательны со скобками - в C++ приоритеты примененных здесь операций в порядке убывания: ()  -  >>  +=  .
То есть среднее равно (sum += adcU - (sum >> k)) >> k  - это без округления, младшие биты просто отбрасываем. С округлением к результату следует прибавить:
```c++
  ((sum >> (k - 1)) & 1);
```
В этом проекте одновременно с подсчетом среднего производится преобразование 12-разрядного ADC в 16-разрядный с помощью простого приема, для этого при вычислении среднего за прошлый интервал результат сдвигается на k плюс число недостающих разрядов ADC, то есть на k + 4. Если бы не одно "но". Когда колебания измеряемого параметра укладываются в единицу счета АЦП, то и результат будет стремиться к "родному" 11-разрядному. С измерением напряжения на батарее скорее всего так и будет (плюс-минус 10 милливольт), а вот с током заряда, где колебания обусловлены физико-химическими процессами, плюс-минус 1 миллиампер вполне достижим. 

А есть ли у метода "скользящее среднее" недостаток? Есть, в начальный период, пока сумматор не накопит достаточного количества измерений, значение среднего может оказаться существенно меньшим, чем реальное значение. Но и здесь не всё так печально. Во-первых, это можно использовать в мирных целях, например для "мягкого старта" системы регулирования. А во-вторых, объявляя сумматор инициализировать его не нулем, а некоторой величиной, например при измерении температуры радиатора задать величину, соответствующую температуре окружающей среды, не забыв сдвинуть влево на "k" разрядов. Для измерителя напряжения ЗУ это будет около 12 вольт. Так сумматор быстрее наберёт необходимое число измерений.
[^](#menu)
***
## <p align="center"> Как это работает. Схема разряда.<a name="discharge"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/i_discharge.png)

Измерение тока разряда производится на том же шунте RS, что и ток заряда, исключая неоднозначность при подсчете залитых и слитых ампер-часов. Для облегчения теплового режима предусмотрен разъем для подключения внешней нагрузки. В случае отсутствия таковой ток ограничивается двух-ваттным резистором. В режиме заряда при чрезмерно малой нагрузке силовой DC/DC автоматически подгружается этим резистором для обеспечения его устойчивой работы, причем этот ток не фиксируется шунтом, а потому не вносит погрешности в подсчет ампер-часов.
[^](#menu)
***
## <p align="center"> Как это работает. Подключение заряжаемой батареи.<a name="akb"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/switch.png)

Здесь ничего нового - схема "цельнотянутая" с прототипа, коим является Кулон 912 и 920-й. Даже предохранитель и 300-амперный диод защиты от повреждения электролитических конденсаторов силового преобразователя при переполюсовке вписались как родные. Но это не более чем перестраховка - при разработке всякое может случиться. Последний барьер не помешает. В качестве ключей применены HEXFET МОП-транзисторы IRLR2905 с высокой скоростью переключения и повышенной лавиноустойчивостью, а также имеющие возможность управляться логическим уровнем. То есть оба изолированных источника в приборе могут быть 5-вольтовые. Посмотрим, оправдается ли такой выбор. Управление ключами производится через оптопару.
[^](#menu)
***
## <p align="center"> Как это работает. Питание модулей.<a name="dc5v"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/power.png)

Питание модулей и схемы подключения батареи, коей нужна "дежурка" с гальваноразвязкой. Оказалось, что это достаточно просто получить, используя 1-ваттный преобразователь из 5 вольт входных в 12 вольт выходных. Аналогичный DC/DC на 5 вольт выходных используется для питания измерительного модуля SAMD21 для сдвига на 200 милливольт в минус от общего провода силового ИП. Эти пребразователи не имеют встроенного стабилизатора, но в обоих случаях это и не требуется. Подключение же их произведено со всеми рекомендациями - самовосстанавливающийся предохранитель на входе, LC-фильтры по входу и выходу, резисторы нагрузки и конденсатор между предполагаемыми "холодными" концами обмоток. 

VD6 следует выбирать с минимальным обратным током, в лучшем случае он добавит пару милливольт к разности напряжений на клеммах.
[^](#menu)
***
## <p align="center"> Как это работает. Силовой DC/DC преобразователь.<a name="power"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/dc_dc.png)

Выбрана схема преобразователя с P-MOSFET IRFP9540 и драйвером MIC4420 как вполне достаточная, чтобы получить возможность отладки алгоритмов управления, оставляя на будущее масштабирование вольтамперных  характеристик. В качестве "донора" был выбран [XL4016 DC-DC Max 9A 300W](https://aliexpress.ru/item/32661166685.html?_ga=2.264151500.1168692661.1643047564-769654542.1642920280&sku_id=12000020944321893&spm=a2g39.orderlist.0.0.60754aa6RxSv8u), силовые компоненты которого, кроме 4016, были перенесены на плату прибора. Рабочая частота была воспроизведена путем настройки режима работы таймера SAMD21. Несмотря на относительно высокую частоту микроконтроллера (48МГЦ) и турбо-режим (72МГц) удалось получить лишь 9-разрядный выход 190-килогерцового ШИМа. Вкупе с ПИД-регулятором это обеспечивает заявленные дискретности установки тока и напряжения 10 мА и 10 мВ.

О резисторе на входе драйвера. Выяснилось, что в процессе работы может последовать включение питания без модуля SAMD21, и, чтобы избежать неконтролируемого напряжения на выходе преобразователя, пришлось подтянуть оказавшийся "в воздухе" вход к плюсу питания. Естественно, что если применен инвертирующий драйвер типа MIC4429, то вход надо подтянуть к общему проводу.
[^](#menu)

***
## <p align="center"> Как это работает. Подключение вентилятора.<a name="cooler"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/cooler.png)

Система управления охлаждением охвачена обратной связью через датчик температуры типа NTC, установленный на радиаторе. Напряжение, подаваемое на вентилятор, управляется ПИД-регулятором. Порог температуры и коэффициенты Kp, Ki и Kd задаются настройками: 
![](https://github.com/olmoro/MKlon3.5/blob/main/documents/full/img/PID_Compensation_Animated.gif)

Как видно из иллюстрации, можно задать как ленивый, так и агрессивный характер системы. Мне понравился агрессивный, он же с перерегулированием - как только температура превысит порог, быстро её "сдуть" типа как бы чего не вышло, и через несколько таких включений-выключений установится некая средняя скорость вентилятора для поддержания температуры на заданном уровне.
[^](#menu)

***
## <p align="center"> Пульт-логгер.<a name="pult"></a>

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/pult/img/iso.png)

Пульт управления, он же логгер с двусторонней беспроводной связью с семейством зарядных устройств. Оснащен кроме карты памяти форм-фактора SD, 5-кнопочной клавиатурой, TFT дисплеем RGB 128x128, шестью разъёмами подключения по протоколу OneWire, зуммером и трехцветным светодиодом. Обмен по беспроводной связи возможен как по каналу WiFi, так и BT одновременно. Устройства OneWire запитаны от 5 вольт и имеют защиту от наводок по питанию и линиям управления. Подключение DS18B20 производится разъёмами 3.5 мм, применяемыми для наушников. Идентификация канала измерения определяется разъемом подключения, без определения уникальных адресов датчиков. Впрочем, возможно и иное.

![](https://github.com/olmoro/MKlon3.5/blob/main/documents/pult/img/pult(1).png)

Питание устройства производится от внешнего адаптера небольшой мощности. Размер платы 100 на 56 мм (плата заимствована из более раннего проекта для управления климатикой базовой станции сотовой связи в корпусе 23-56A с заменой ESP32 на 30-выводной модуль).

[Документация](https://github.com/olmoro/MKlon3.5/tree/main/documents/pult)
[^](#menu)

***
## <p align="center">2. Как это работает. Программный аспект.<a name="soft"></a>

В директории src представлен полный комплект ПО прототипа с дисплеем 1,8 дюйма версии MKlon2.7a для модуля ESP32D.

## <p align="center"> Как это работает. Структура проекта.<a name="main"></a>
Условно программную часть можно разделить на системную и целевую. Соответственно системная - зона ответственности разработчика за поддержку аппаратной части прибора и ничего, ну почти ничего не понимающего в аккумуляторах, а целевая - ответственность гуру в алгоритмах поддержки процессов при обслуживании батарей и мало смыслящего в тонкостях кодирования. Из этого следует, что набор приемов для него должен адаптировать системщик. В идеале, конечно ... но мне известен такой лишь один (Андрей З.).

Итак, для системщика, недавно пришедшего с Arduino совсем коротко: 

### <p align="left">Задачи Free RTOS:
- Connect - управление беспроводным интерфейсом;
- Main - управление выбором и исполнением выбранного режима; 
- Display - управление отображением на дисплее;
- Cool - управление системой охлаждения;
- Measure - обработка измерений питания, температуры, выхода кнопок, фильтрация;
- Driver - отправка команд на силовой блок;
- Loop - фоновая, прием ответа от силового блока.

Все задачи исполняются ядром 1, ядро 0 выделено для радиочастотных задач - BT и WiFi, что соответствует конфигурации Arduino по умолчанию. 

Для понижения порога вхождения в программирование под Free RTOS использование возможностей операционной системы сведено к разумному минимуму.

### <p align="left">Меню выбора режимов:

- BOOT - синхронизация параметров микроконтроллеров при подаче питания;
- OPTIONS - операции с пользовательскими настройками;
- UPID - тестовый режим экспериментов с пид-регулятором по напряжению;
- IPID - тестовый режим экспериментов с пид-регулятором по току заряда;
- DPID - тестовый режим экспериментов с пид-регулятором по току разряда;
- TEMPLATE - шаблон режима; 
- CCCV - режим заряда "постоянный ток / постоянное напряжение" - не откорректирован;
- CCCVT - то же для экспериментов;
- DEVICE - регулировки калибровок, выбор параметров фильтрации и др.

### <p align="left">Сохранение настроек:

Единственным местом хранения настроек обоих микроконтроллеров является энергонезависимая память (NVS) ESP32. При доступе к данным используются имена разделов и ключи параметров. Значения ключей вкупе с их именами могут быть удалены при необходимости. Реализован такой алгоритм удаления: при входе в выбранный режим 7-кратное нажатие кнопки "B" инициирует удаление всех или по выбору ключей данного раздела.

### <p align="left">Регистр состояния:

Состояние контроллера силового блока автоматически добавляется в каждом сеансе запроса текущего напряжения и тока в нагрузке. Формат битовый.
- status_switch           - DC-DC подключен к клеммам;
- status_power            - DC-DC включен;
- status_current_control  - пид-регулятор в режиме контроля тока;
- status_voltage_control  - пид-регулятор в режиме контроля напряжения;
- status_charge           - заряд включен;
- status_discharge        - разряд включен;
- status_auto_mode        - пид-регулятор в автоматическом режиме;
- status_pid              - регулирование идёт под пид-регулятором;
- status_overheating      - фиксируется перегрев;
- status_overload         - фиксируется перегрузка;
- status_power_limit      - фиксируется перегрузка по мощности;
- status_reverse_polarity - фиксируется переполюсовка;
- status_short_circuit    - фиксируется короткое замыкание нагрузки;
- status_calibration      - резерв;
- status_upgrade          - резерв;
- status_reserve2         - резерв;

### <p align="left">Обмен данными между задачами:

Обмен синхронизирован, так что до применения очередей Free RTOS дело так и не дошло. Все данные имеют тип int16_t. Потерь и искажения данных из-за (не)атомарности не замечено. Похоже, что технология Arduino здесь что-то делает за нас - профи пусть уточнят сей момент.

### <p align="left">Используемые библиотеки:

- TFT_eSPI @ 2.3.59
- AutoConnect @ 0.9.9
- PageBuilder @ 1.3.3
- ArduinoJson @ 6.11.0
- AutoPID @ 1.0.3
- Button  http://samopal.pro/arduino-button-2/

Во избежание мелких недоразумений библиотеки размещены непосредственно в проекте

### <p align="left">Команды обмена между модулями по асинхронному интерфейсу:

1. Команды чтения результатов измерений
- txReadUIS() - запрос на получение текущего значения тока, напряжения и состояния;
- txGetState() - то же только состояния;
2. Команды stop/go
- txPowerAuto(float spV, float spI) - задать параметры DCDC и включить;
- txPowerStop()- DCDC выключить;
- txPowerMode(float spV, float spI, uint8_t mode) - тестовое включение с выбором режима ПИД;
- txDischargeGo(float spI) - задать ток разряда и подключить;
3. Команды работы с измерителями
- txGetFactorU() - запросить коэффициент преобразования в милливольты;
- txSetFactorU(short val) - записать;
- txSetFactorDefaultU() - восстановить заводское значение;
- txGetSmoothU()- запросить параметр сглаживания по напряжению;
- txSetSmoothU(short val) - записать;
- txGetShiftU() - запросить приборный сдвиг по напряжению;
- txSetShiftU(short val) - записать;
- txGetFactorI() - запросить по току;
- txSetFactorI(short val);
- txSetFactorDefaultI();
- txGetSmoothI();
- txSetSmoothI(short val);
- txGetShiftI();
- txSetShiftI(short val);
4. Команды работы с ПИД-регулятором
- txSetPidConfig(uint8_t m, float kp, float ki, float kd, uint16_t minOut, uint16_t maxOut);
- txSetPidCoeff(unsigned short m, float kp, float ki, float kd);
- txSetPidCoeffV(float kp, float ki, float kd);
- txSetPidCoeffI(float kp, float ki, float kd);
- txSetPidCoeffD(float kp, float ki, float kd);
- txSetPidOutputRange(uint8_t m, uint16_t minOut, uint16_t maxOut);
- txSetPidReconfig(uint8_t m, float kp, float ki, float kd, uint16_t minOut, uint16_t maxOut);
- txPidClear();
- txGetPidTreaty() - согласование параметров при обмене;
- txGetPidConfig() - запросит текщие настройки ПИД-регулятора
- txSetPidFrequency(unsigned short hz) - изменить частоту регулирования;
5. Тестовые    
- txGetProbes();
- txGetAdcOffset();
- txSetAdcOffset(short val);
- txAdcAutoOffset() - не реализована, резерв;
6. И ещё команды, полный список см. в файле mtools.h.


### <p align="left">Компиляция версии MKlon2v7a от 26 марта 2023г:

PLATFORM: Espressif 32 (3.5.0) > Espressif ESP32 Dev Module

HARDWARE: ESP32 240MHz, 320KB RAM, 4MB Flash
RAM:   [=         ]  14.8% (used 48460 bytes from 327680 bytes)
Flash: [========= ]  94.4% (used 1237806 bytes from 1310720 bytes

HARDWARE: ESP32 240MHz, 320KB RAM, 16MB Flash
RAM:   [=         ]  14.8% (used 48460 bytes from 327680 bytes)
Flash: [==        ]  18.9% (used 1237806 bytes from 6553600 bytes)

[^](#menu)
***

## <p align="center"> Как это работает. State.<a name="state"></a>

В проекте многие процессы реализованы как конечные автоматы (Finite State Maсhine, FSM), в виде последовательности шагов от одного состояния к другому. Выбран конечный автомат Мура, где выход определяется однозначно тем состоянием, в которое автомат переходит после приема входного сигнала. 
Реализацию состояния рассмотрим позже, а пока - основа проекта - базовый класс MState, отвечающий за переход между состояниями. Не приходилось использовать виртуальные функции? Мне тоже.

### <p align="left">файл mstate.h
```c++
#ifndef _MSTATE_H_
#define _MSTATE_H_

class MTools;

class MState
{
  public:
    MState(MTools * Tools);
    virtual ~MState(){}
    virtual MState * fsm() = 0;
  protected:
    MTools * Tools = nullptr;
};

#endif
```

Функция fsm() объявлена виртуальной, в файлах реализации режимов наследуется как виртуальная и возвращает указатель на вызываемое состояние: this - в нашем случае при следующем вызове оставаться в том же состоянии, или назначить указатель через оператор new для перехода в иное состояние. Специальный указатель nullptr используется для завершения работы автомата.
Класс MTools - класс утилит, которыми в конечном итоге пользуется разработчик целевого проекта.

### <p align="left">файл mstate.cpp
```c++
#include "mstate.h"
#include "mtools.h"

MState::MState(MTools * Tools) : Tools(Tools) {}
```

Более подробно это изложено в разделе [FSM](#fsm).
 [^](#menu)

***
## <p align="center">3. Технические характеристики MKlon4.0<a name="specifications"></a>

- Зарядный ток Iз, А _____________________________ 0.05 – 6.0 ±(0.005 Iз + 0.05)
- Шаг установки зарядного тока, А _____________ 0.01 
- Зарядное напряжение U, В ____________________ 1.0 – 18.0 ±(0.005 U + 0.05)
- Шаг установки зарядного напряжения, _______ 0.01
- Разрядный ток Iр, А ____________________________ 0.05 – 3.0 ±(0.005 Iр + 0.05)
- Шаг установки разрядного тока, А ____________ 0.01
- Максимальная рассеиваемая мощность, Вт __ не менее 40
- Питание от внешнего AC/DC __________________ ноутбучный 19 В (4.74 ... 6.0 А)
- Интерфейс _____________________________________ USB, WiFi, BT
- Индикация _____________________________________ TFT 3.5 или 4.0, сенсорная панель 
- Диагностика ___________________________________ 2 разъема для логического анализатора
- Micro-SD карта ________________________________ на дисплее
- Защита по выходу _____________________________ переполюсовка, перегрузка по току, КЗ

***
